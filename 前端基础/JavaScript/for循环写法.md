### 1. 最基础写法

```js	
for(let i=0;i<arr.length;i++){
    // 
}
```
	
常见正序for循环。
	
#### 缺点：

每次从arr中取length来和i比较，浪费性能，而且如果arr的长度是动态变化的，就会出现死循环
	
### 2. 缓存数组length
	
```js
for(let i=0,len=arr.length;i<len;i++){
	//
}
```
	
通过缓存arr的length，来提升性能，数组越长越明显
	
### 3. 倒序循环

```js	
for(let i=arr.length-1;i>=0;i++){
    //
}
```
	
减少第二种方法申请的len变量，且对length缓存过
	
### 4. 精简倒序循环

```js	
for(let i=arr.length;i--;){
    console.log(arr[i])
    let obj = arr[i]
}
```
	
#### 原理：

循环体是否执行的条件是：；；之间的条件是否为真，而i--先判断后减的特性，使得第一次循环时，i--=arr.length,等进入循环体后i--减操作完成，i=arr.length-1;当i=1时，i--=1,进入循环体，i取值0；等下一次i=0时，i--=0，条件为false，不再进入循环体
	
循环中新申请变量=当前数组项，不妥，jsLint也会提醒不要在循环中申请变量
	
### 5. 正序效率高变量少
	
```js
for(let i=0,a;a=arr[i++];){
    //
}
```
	
#### 原理：

a = arr[i++] ，在这里作为循环能执行的条件，注意这里只有一个=号，所以这不是判断句，是赋值语句，就是把arr[i++]赋给a，然后判断a是不是真值。i++与i–的原理类型我就不说了，只说当i++已经超过数组的长度时，循环肯定要停止才行，而这里真的就停止了，为什么？因为a=arr[i++] ，如果取到了超出数组本身长度的项，只会取得一个undefined，而undefined是假值，循环条件就判断失败了。
	
#### 缺点：

当数组长度动态变化时，依旧会产生死循环，因为没缓存过数组长度当数组某一项值，为0，false，null，undefined等判读为false的值时，会终止循环
	
	
### 提高for循环性能：
	
- 适时break，不需要循环所有就加跳出条件
	
- 不要在for循环里声明变量，建议一次申请，多次赋值
	
- 数组长度缓存，尽量少变量
