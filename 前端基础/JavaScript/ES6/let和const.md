# let
## 1. 块级作用域
	
let定义的变量只在所在的作用域内有效。for循环的计数器适合用let命令。
	
```js
var a = [];
for(var i=0;i<10;i++){
    a[i] = function(i){
        console.log(i);
    }
}
a[6](); // 10
```
	
使用let定义则i为作用域内i，a[6]()为6

## 2. for循环的两层作用域
	
设置循环体的部分为父作用域，而循环体内部为单独的子作用域
	
```js
for(let i=0;i<3;i++){
    let i = 'hello';
    console.log(i);
}
// hello
// hello
// hello
```

## 3. 不存在变量提升
	
var 定义的变量会 变量提升，即变量在声明之前就可以使用，值为undefined

而let声明的变量要在声明后才能使用，否则报错
```js	
// var
console.log(a); // undefined
var a = 2;

// let 
console.log(b); // 报错ReferenceError
let b = 2;
```

## 4. 暂时性死区
	
只要块级作用域内存let，那么let定义的变量就只能在定义后再使用，否则报错。

即使在父级作用域中已经定义过了。es6规定，区块中存在let和const命令，那么声明的变量从一开始就形成了封闭作用域，一进入这个作用域，变量就存在了，但是不可获取，只有等到声明变量的哪一行出现才可以获取和使用变量，称为暂时性死区。
```js
let a = 2;
if(true){
    console.log(a);  // 报错 定义前不能使用
    let a = 3;
}
```

## 5. 不可重复声明
	
同一个块级作用域内，同一个变量不能重复声明，避免在函数内声明参数
```js
function name(){
    let obj = {};
    var obj = {}; // 报错
    
    let name = '2';
    let name = '3'; // 报错
}

function fun(arg){
    let arg = '2'; // 报错
    {
        let arg = '3'; // 不报错
    }
}
```

## 6. 块级作用域的任意嵌套
	
允许代码块任意嵌套，每一层嵌套形成单独的块级作用域，外层嵌套不可访问内层作用域中的变量
```js
{
    let obj = {}
    {
        let name = 'guo'
        {
            {
                console.log(2)
            }
        }
    }
}

// 块级作用域的出现，使得广泛应用的匿名函数不在需要了

// IIFE 
(function(){
    var tamp = '';
}());

// let
{
    let temp = '';
}
```

## 7. 块级作用域与函数声明
	
ES5规定，函数只能在顶层作用域和函数作用域中声明，不能在块级作用域中声明
	
```js
if(true){
    function f(){}
}

try{
    function f(){}
}catch(err){

}
```
	
以上两种情况，ES5规定都是非法的，但浏览器为了兼容旧代码，还是支持在块级作用域中声明函数，因此上面情况实际运行可以，不报错。
	
而在ES6中，块级作用域中可以声明函数。但是为了兼容旧代码，也规定，浏览器的实现可以不遵守这个规定，有自己的行为方式。
	
	- 允许在块级作用域内声明函数。
	- 函数声明类似var，即会提升到全局作用域或函数作用域的头部。
	
这两条规则，只对ES6的浏览器实现有效，其他环境不用遵守，块级作用域内的函数声明还当let处理。
	
所以在ES6浏览器环境中，
	
```js
（function (){
    if(false){
        function fun(){ console.log(1);}
    }
    fun();
}());
```
	
	实际会变成
```js
（function (){
    var fun = undefined;
    if(false){
        function fun(){ console.log(1);}
    }
    fun();
}());
```
	
会发生报错。
	
	
所以，如果需要在块级作用域中声明函数，最好写成函数表达式的形式。

# const

声明一个只读常量，一旦声明，常量的值就不能改变。

声明时必须初始化，不能留到以后赋值。

作用域与let相同，只在声明所在的块级作用域有效。

声明的常量不提升，存在暂时性死区，只能在声明后再使用。

不可重复声明。

常量的值不能改变的本质不是变量的值不能改动，而是变量指向的那块内存地址所保存的值不能改动。所以对于复杂数据类型，如数组、对象来说，使用const声明要慎重。